#include <iostream>
#include <stdlib.h> //using quick sort
#include <stdio.h>
#include <queue> //using stl queue
using namespace std;
struct node
{
int data;
bool check; //To distinguish when data is same
};

int compare_func(const void* arg1,const void* arg2){ //sorted by data of struct
    struct node *a, *b;
    a=(struct node *)arg1;//point struct node a
    b=(struct node *)arg2;//point struct node b

    if(a->data > b->data) return -1;//compare struct node -> data
    else if(a->data < b->data) return 1;
    else return 0;
}

int main() {
	int L = 0;//Test case
	cin>>L;
	for(int i = 0 ; i < L ; i++){
		int N = 0 , M = 0;
		cin>>N;
		cin>>M;
		struct node array[N] = {};
		queue<struct node> q;
		for(int j = 0 ; j < N ; j++){
			int input;
			cin>>input;
			array[j].data = input;
			if(M == j)
				array[j].check = true; // answer node
			else
				array[j].check = false;
			q.push(array[j]);
		}

		qsort(array, N, sizeof(array[0]), compare_func); //desending order sort 
		int s = 0, count = 0;
		while(true){
			if(array[s].data == q.front().data){
				if(q.front().check){
					cout<<count+1<<endl;//Answer count from 1.
					break;
				}else {
					s++;
					q.pop();
					count++;
				}
			}else {//array priority > front of queue
				struct node temp;
				temp.data = q.front().data;
				temp.check = q.front().check;
				q.pop();//Return type of pop() is void. so I declear temp node for push again
				q.push(temp);
			}
		}
	}
	return 0;
}
